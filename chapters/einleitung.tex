Kryptographische Verfahren wie Verifikation digitaler Daten sind seit jeher wichtig für die Kommunikation auf unsicheren Kanälen.
Gerade vernetzte Kleinstrechner wie IoT-Geräte sind aufgrund ihrer geringen Leistungsfähigkeit sehr anfällig für Angreifer.
Verfahren zur Programmverifikation können dem entgegenwirken, benötigen jedoch verhältnismäßig viel Rechenleistung.
Mit Hilfe spezialisierter Hardware, die die nötigen Aufgaben effizienter ausführt, kann dieser zusätzliche Aufwand reduziert werden.
Rekonfigurierbare Prozessoren können hier Abhilfe schaffen. Sie erlauben es, kleine Hardwarebeschleuniger zur Laufzeit zu laden,
wenn sie benötigt werden und rechenintensive Aufgaben zu erledigen. Gleichzeitig müssen sie auch nicht für das spezielle
Einsatzgebiet angefertigt werden, sondern können nachträglich spezialisiert werden, was auch die Produktionskosten reduziert.
Des Weiteren können die zur Verfügung gestellten Beschleuniger-Blöcke zusätzlich auch für weitere einsatzspezifische Aufgaben verwendet werden.

In dieser Arbeit soll daher einen Beschleuniger für einen rekonfigurierbaren Prozessor entwickelt werden, der die Berechnung einer
kryptographischen Hashfunktion optimiert, dem Herzstück vieler Verifizierungsalgorithmen. Dabei soll der i-Core (siehe Kapitel \ref{cha:icore}) als Prozessorarchitektur
dienen und konkret soll eine SHA-3-Hashfunktion für ihn implementiert werden. SHA-3 ist eine relativ neue Familie an Hashfunktionen,
die auch in naher Zukunft noch viel Sicherheit verspricht und viele Probleme bisheriger Hashfunktionen verbessert.
Dazu wollen wir uns zuerst einmal den i-Core, sowie SHA-3 genauer anschauen und einen Einblick in ihre Funktionsweisen erhalten.

Danach wird der Entwurfsprozess des Beschleunigers vorgestellt. Das Ziel ist es ein Design zu entwickeln, das die Anforderungen
der i-Core-Architektur erfüllt und möglichst viel seines Leistungspotentials dabei ausschöpft. Dabei werden wir uns
verschiedene aufeinander aufbauende Entwürfe anschauen. Zu Jedem werden die getroffenen Entwurfsentscheidungen diskutiert und die
Notwendigkeit gewisser Einschnitte in der Leistungsfähigkeit zur Erfüllung der Anforderungen erläutert. Außerdem werden Ansätze
vorgestellt, mit denen die Anforderungen mit nur geringen Leistungseinbußen eingehalten werden können.

Am Ende werden die verschiedenen Ansätze untereinander verglichen und besonders gute Aspekte herausgearbeitet,
sowie weitere Optimierungsansätze aufgezeigt, die die Leistungsfähigkeit noch weiter steigern können. Außerdem wird der entworfene Beschleuniger
mit einer Software-Implementierung verglichen und der tatsächliche Speedup des Beschleuniger gegenüber der stumpfen Software-Berechnung bestimmt.