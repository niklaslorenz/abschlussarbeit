\chapter{Einleitung}
\input{chapters/einleitung.tex}

\chapter{i-Core}
\input{chapters/icore.tex}

\chapter{SHA-3}
\input{chapters/sha3}

\chapter{Implementierung}
\input{chapters/vorgehensweise.tex}
\input{chapters/iteration_1}
\newpage
\input{chapters/iteration_2}
\input{chapters/iteration_2_rho_transformation}
\newpage
\input{chapters/iteration_3}

\chapter{Ergebnisse}
\input{chapters/auswertung.tex}

\chapter{Fazit}
\input{chapters/fazit.tex}

\chapter{Ã„hnliche Arbeiten}
\input{chapters/aehnliche_arbeiten.tex}

\chapter{Glossar}
\input{chapters/glossar.tex}

\chapter{Symbolverzeichnis}
\input{chapters/symbolverzeichnis.tex}

\chapter{Anhang 1: Softwareimplementierung}
\label{cha:anhang1}
\input{chapters/anhang1_software_implementierung.tex}


\chapter{Template Stuff that is still here}

\section{Some Template Comments}
\label{sec:comments}

\begin{outline}
  \1 It is recommended to use one sentence per line of the latex source code.
  That is a good compromise between (i) `diffs' when using repositories, and (ii) forward-/backward search between latex source code and pdf output.
  \1 Note that you can have multiple refs in the same \textbackslash cref block (e.g., \cref{sec:motivation,sec:comments,sec:statement,sec:results,fig:popcount}), but there must not be spaces after the commas.
  \1 Note that you should use \textbackslash Cref (upper-case C) at the beginning of a sentence and \textbackslash cref (lower-case c) in the middle of a sentence.
  They are defined differently, such that the upper-case C version does not use abbreviations (which is recommended for the beginning of a sentence), e.g., \cref{eq:node} vs. \Cref{eq:node}.
  \1 You can use the outline environment to collect itemized points before actually writing your text.
    \2 It helps structuring your ideas by simplifying indentation of items
    \3 Like here.
\end{outline}


\section{Problem Statement}
\label{sec:statement}

Based on a partitioning $P \subset 2^V$, i.e., $p_i, p_j \in P, p_i \ne p_j \Rightarrow p_i \cap p_j = \emptyset, \bigcup\limits_P = V$, an equivalence relation $\sim_P$ as well as the partition graph $G_P$ are defined as follows:
\begin{align}
  \sim_P &= \{(v_1,v_2) \in V | \exists p \in P: v_1\in p \wedge v_2 \in p\}\\
  G_P &= (V_P, E_P) = (V/\sim_P, \{ ([v_1]_{\sim_P}, [v_2]_{\sim_P}) |\: (v_1,v_2) \in E \})
  \label{eq:node}
\end{align}



\section{Results}
\label{sec:results}

Following is the discussion of obtained results.

\begin{figure}[ht]
  \center
  \includegraphics[scale=0.33]{searchtree.pdf}
  \caption{Topologically sorted DFG along with the complete search tree of the partition enumeration algorithm.}
  \label{fig:searchtree}
\end{figure}



\begin{table}
  \centering
  \begin{tabular}{lrrrr}
                &   types  &      types  &   atoms  &      atoms  \\
    SI          &  manual  &  generated  &  manual  &  generated  \\
    \hline
    htfour      &       1  &          4  &       8  &         81  \\
    satdfour    &       3  &          8  &      16  &        104  \\
    dctfour     &       2  &          9  &      12  &         90  \\
    sadsixteen  &       1  &          4  &      64  &        255  \\
  \end{tabular}
  \caption{Comparison of generated SI graphs vs. hand-crafted ones.}
  \label{tab:manualeval}
\end{table}


\begin{figure}
\lstset{language=C}
\begin{lstlisting}[label={lst:popcount}]
uint32_t popcount_a(uint32_t x)
{
  x -= ((x >> 1) & 0x55555555);
  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
  x = (x + (x >> 4)) & 0x0f0f0f0f;
  x += x >> 8;
  x += x >> 16;
  return x & 0x3f;
}
\end{lstlisting}
\caption{C-Code from \cite{warren2003hacker} to compute the number of set bits of a 32-bit value.}
\label{fig:popcount}
\end{figure}

